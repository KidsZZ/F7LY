我最新的调试发现了这个问题。在前面4096复制测试的时候，都是在fd3中lseek到3，fd4中lseek到6，所以copy的时候是从第三个字节开始读，第六个字节开始写，其余部分用0填充。前面fd3的大小是8192，从3开始写8185个字节不会错位。但是fd4从第6字节开始写，写8185个字节就可能错位。对于fd4的操作只有ftruncate. 后面也显示我们的lseek确实把文件4大小截断为0了。

那么我就想了，从一个大小为0的文件的第六个字节开始写，这个文件会不会溢出到别的地方去呢？如果真的从第六个地方写那么前六个字节肯定还是00这就是compare的内容所在，但是8185的测试之后就不是这样，整个文件都不是00了，所以肯定是超过一个页面之后的写有问题。

我们发现copyfilerange其实是包装后的read和write，在测试上的区别就是他有点需要稀疏文件，lseek指针到6的位置开始写。上午通过序列观察、复现操作，发现了其实是先lseek后写会爆磁盘，而不是其余操作本身的问题。

官老师说lseek的库函数直接把边界检查删掉了，以此来完成稀疏文件。但是这样可能破坏了库函数的一体性。我们把这样的实现先复原，改成用我们自己的虚拟文件的指针来做一个虚拟指针，而在写的时候再填充，重新实现了稀疏文件。

好了到了最后一关99999buf的时候，copyin缓冲区的字符串爆了，这是因为file和buf都是通过堆进行管理的，当buf过大的时候分配的区域不足，直接把file结构体冲掉了。
```
file size: 0, file offset: 0
f:0x000000009b2b3000, buf: 0x000000009b2ac000, n: 99999
file size: 6343063318725871709, file offset: 5712320550306390108
```
所以我考虑把缓冲区换到k_pmm进行管理，物理内存部分用来管理所有文件，而堆内存用于管理各种结构体、内存结构。这样就不会引起冲突.