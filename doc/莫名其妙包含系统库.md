当我发现一个for循环语法用不了时，我想把cpp的标准从17提升到20进行编译，但是一提升报了一万个错出来
提示的都是各种重定义：
```sh
                 from kernel/boot/riscv/main.cc:12:
kernel/libs/klib.hh:56:16: error: conflicting declaration of ‘int vsnprintf(char*, size_t, const char*, va_list)’ with ‘C++’ linkage
   56 |         int    vsnprintf( char *str, size_t size, const char *format, va_list ap );
      |                ^~~~~~~~~
In file included from /usr/riscv64-linux-gnu/include/features.h:502,
                 from /usr/riscv64-linux-gnu/include/sys/types.h:25,
                 from kernel/devs/../types.hh:4,
                 from kernel/devs/spinlock.hh:5,
                 from kernel/devs/uart.hh:3,
                 from kernel/boot/riscv/main.cc:1:
/usr/riscv64-linux-gnu/include/bits/stdio2.h:65:1: note: previous declaration with ‘C’ linkage
   65 | __NTH (vsnprintf (char *__restrict __s, size_t __n,
      | ^~~~~
In file included from /usr/riscv64-linux-gnu/include/time.h:33,
                 from /usr/riscv64-linux-gnu/include/pthread.h:23,
                 from /usr/riscv64-linux-gnu/include/c++/11/riscv64-linux-gnu/bits/gthr-default.h:35,
                 from /usr/riscv64-linux-gnu/include/c++/11/riscv64-linux-gnu/bits/gthr.h:148,
                 from /usr/riscv64-linux-gnu/include/c++/11/bits/atomic_wait.h:38,
                 from /usr/riscv64-linux-gnu/include/c++/11/bits/atomic_base.h:41,
                 from /usr/riscv64-linux-gnu/include/c++/11/atomic:41,
                 from kernel/devs/spinlock.hh:7,
                 from kernel/devs/uart.hh:3,
                 from kernel/boot/riscv/main.cc:1:
kernel/tm/time.hh:28:17: error: expected identifier before numeric constant
   28 |                 CLOCK_REALTIME = 0,
      |                 ^~~~~~~~~~~~~~
```
fuck
不管加多少个`-ffreestanding`,`-nostdlib`这种标志都没用。
仔细一看unistd.h，这是怎么包含进来的，我怎么都不会用到这个库吧？
于是陷入深深的崩溃之中。
经高人指点，告诉我可以搜索什么地方可能会包含unistd。所以对所有的包含了的标准库都开始检索。
下面是`<atomic>`里面`<atomic_base>`的代码
```c
#if __cplusplus > 201703L && _GLIBCXX_HOSTED
#include <bits/atomic_wait.h>
#endif
```
那很明显就是17一改就多包含了
然后在atomic_wait里就看到了那几个报错的源头:
```c

#ifdef _GLIBCXX_HAVE_LINUX_FUTEX
# include <cerrno>
# include <climits>
# include <unistd.h>
# include <syscall.h>
# include <bits/functexcept.h>
#endif
```
好的，那么这个宏我怎么取消呢?这个宏（包括 `_GLIBCXX_HOSTED`）定义在c++config里面
```c
/* Define to 1 if you have the <link.h> header file. */
#define _GLIBCXX_HAVE_LINK_H 1

/* Define if futex syscall is available. */
#define _GLIBCXX_HAVE_LINUX_FUTEX 1

/* Define to 1 if you have the <linux/random.h> header file. */
#define _GLIBCXX_HAVE_LINUX_RANDOM_H 1

```
然后根本无法被重覆盖定义，如果改这个文件，以后用cpp的时候有你好看的。
怎么办呢？
那么，为什么学长他们的代码没有爆呢？我们重读一下代码
```c

#include <atomic>

namespace hsai
{
...
```
确实是包含了atomic，当我看了下别人修改学长的时候，发现别人的突然变成了
```c
#include <EASTL/atomic.h>
```
欸怎么就没有了。
然后我满心欢喜地去改我的，然后发现EASTL没有atomic，噢原来是.h啊，那没事了
